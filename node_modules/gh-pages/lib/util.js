const path = require('path');
<<<<<<< Updated upstream
const Git = require('./git');
=======
const Git = require('./git.js');
>>>>>>> Stashed changes
const async = require('async');
const fs = require('fs-extra');

/**
 * Generate a list of unique directory paths given a list of file paths.
<<<<<<< Updated upstream
 * @param {Array.<string>} files List of file paths.
 * @return {Array.<string>} List of directory paths.
 */
const uniqueDirs = (exports.uniqueDirs = function(files) {
  const dirs = {};
  files.forEach(filepath => {
    const parts = path.dirname(filepath).split(path.sep);
    let partial = parts[0] || '/';
    dirs[partial] = true;
    for (let i = 1, ii = parts.length; i < ii; ++i) {
      partial = path.join(partial, parts[i]);
      dirs[partial] = true;
    }
  });
  return Object.keys(dirs);
});
=======
 * @param {Array<string>} files List of file paths.
 * @return {Array<string>} List of directory paths.
 */
function uniqueDirs(files) {
  const dirs = new Set();
  files.forEach((filepath) => {
    const parts = path.dirname(filepath).split(path.sep);
    let partial = parts[0] || '/';
    dirs.add(partial);
    for (let i = 1, ii = parts.length; i < ii; ++i) {
      partial = path.join(partial, parts[i]);
      dirs.add(partial);
    }
  });
  return Array.from(dirs);
}
exports.uniqueDirs = uniqueDirs;
>>>>>>> Stashed changes

/**
 * Sort function for paths.  Sorter paths come first.  Paths of equal length are
 * sorted alphanumerically in path segment order.
 * @param {string} a First path.
 * @param {string} b Second path.
 * @return {number} Comparison.
 */
<<<<<<< Updated upstream
const byShortPath = (exports.byShortPath = (a, b) => {
=======
function byShortPath(a, b) {
>>>>>>> Stashed changes
  const aParts = a.split(path.sep);
  const bParts = b.split(path.sep);
  const aLength = aParts.length;
  const bLength = bParts.length;
  let cmp = 0;
  if (aLength < bLength) {
    cmp = -1;
  } else if (aLength > bLength) {
    cmp = 1;
  } else {
    let aPart, bPart;
    for (let i = 0; i < aLength; ++i) {
      aPart = aParts[i];
      bPart = bParts[i];
      if (aPart < bPart) {
        cmp = -1;
        break;
      } else if (aPart > bPart) {
        cmp = 1;
        break;
      }
    }
  }
  return cmp;
<<<<<<< Updated upstream
});

/**
 * Generate a list of directories to create given a list of file paths.
 * @param {Array.<string>} files List of file paths.
 * @return {Array.<string>} List of directory paths ordered by path length.
 */
const dirsToCreate = (exports.dirsToCreate = function(files) {
  return uniqueDirs(files).sort(byShortPath);
});

/**
 * Copy a file.
 * @param {Object} obj Object with src and dest properties.
 * @param {function(Error)} callback Callback
 */
const copyFile = (exports.copyFile = function(obj, callback) {
=======
}
exports.byShortPath = byShortPath;

/**
 * Generate a list of directories to create given a list of file paths.
 * @param {Array<string>} files List of file paths.
 * @return {Array<string>} List of directory paths ordered by path length.
 */
function dirsToCreate(files) {
  return uniqueDirs(files).sort(byShortPath);
}
exports.dirsToCreate = dirsToCreate;

/**
 * Copy a file.
 * @param {object} obj Object with src and dest properties.
 * @param {function(Error)} callback Callback
 */
function copyFile(obj, callback) {
>>>>>>> Stashed changes
  let called = false;
  function done(err) {
    if (!called) {
      called = true;
      callback(err);
    }
  }

  const read = fs.createReadStream(obj.src);
<<<<<<< Updated upstream
  read.on('error', err => {
=======
  read.on('error', (err) => {
>>>>>>> Stashed changes
    done(err);
  });

  const write = fs.createWriteStream(obj.dest);
<<<<<<< Updated upstream
  write.on('error', err => {
=======
  write.on('error', (err) => {
>>>>>>> Stashed changes
    done(err);
  });
  write.on('close', () => {
    done();
  });

  read.pipe(write);
<<<<<<< Updated upstream
});
=======
}
exports.copyFile = copyFile;
>>>>>>> Stashed changes

/**
 * Make directory, ignoring errors if directory already exists.
 * @param {string} path Directory path.
 * @param {function(Error)} callback Callback.
 */
function makeDir(path, callback) {
<<<<<<< Updated upstream
  fs.mkdir(path, err => {
=======
  fs.mkdir(path, (err) => {
>>>>>>> Stashed changes
    if (err) {
      // check if directory exists
      fs.stat(path, (err2, stat) => {
        if (err2 || !stat.isDirectory()) {
          callback(err);
        } else {
          callback();
        }
      });
    } else {
      callback();
    }
  });
}

/**
 * Copy a list of files.
<<<<<<< Updated upstream
 * @param {Array.<string>} files Files to copy.
=======
 * @param {Array<string>} files Files to copy.
>>>>>>> Stashed changes
 * @param {string} base Base directory.
 * @param {string} dest Destination directory.
 * @return {Promise} A promise.
 */
<<<<<<< Updated upstream
exports.copy = function(files, base, dest) {
  return new Promise((resolve, reject) => {
    const pairs = [];
    const destFiles = [];
    files.forEach(file => {
=======
exports.copy = function (files, base, dest) {
  return new Promise((resolve, reject) => {
    const pairs = [];
    const destFiles = [];
    files.forEach((file) => {
>>>>>>> Stashed changes
      const src = path.resolve(base, file);
      const relative = path.relative(base, src);
      const target = path.join(dest, relative);
      pairs.push({
        src: src,
<<<<<<< Updated upstream
        dest: target
=======
        dest: target,
>>>>>>> Stashed changes
      });
      destFiles.push(target);
    });

<<<<<<< Updated upstream
    async.eachSeries(dirsToCreate(destFiles), makeDir, err => {
      if (err) {
        return reject(err);
      }
      async.each(pairs, copyFile, err => {
=======
    async.eachSeries(dirsToCreate(destFiles), makeDir, (err) => {
      if (err) {
        return reject(err);
      }
      async.each(pairs, copyFile, (err) => {
>>>>>>> Stashed changes
        if (err) {
          return reject(err);
        } else {
          return resolve();
        }
      });
    });
  });
};

<<<<<<< Updated upstream
exports.getUser = function(cwd) {
  return Promise.all([
    new Git(cwd).exec('config', 'user.name'),
    new Git(cwd).exec('config', 'user.email')
  ])
    .then(results => {
      return {name: results[0].output.trim(), email: results[1].output.trim()};
    })
    .catch(err => {
=======
exports.getUser = function (cwd) {
  return Promise.all([
    new Git(cwd).exec('config', 'user.name'),
    new Git(cwd).exec('config', 'user.email'),
  ])
    .then((results) => {
      return {name: results[0].output.trim(), email: results[1].output.trim()};
    })
    .catch((err) => {
>>>>>>> Stashed changes
      // git config exits with 1 if name or email is not set
      return null;
    });
};
