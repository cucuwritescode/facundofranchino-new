const findCacheDir = require('find-cache-dir');
<<<<<<< Updated upstream
const Git = require('./git');
const filenamify = require('filenamify');
const copy = require('./util').copy;
const getUser = require('./util').getUser;
=======
const Git = require('./git.js');
const filenamify = require('filenamify');
const copy = require('./util.js').copy;
const getUser = require('./util.js').getUser;
>>>>>>> Stashed changes
const fs = require('fs-extra');
const globby = require('globby');
const path = require('path');
const util = require('util');

const log = util.debuglog('gh-pages');

/**
 * Get the cache directory.
 * @param {string} [optPath] Optional path.
<<<<<<< Updated upstream
 * @returns {string} The full path to the cache directory.
=======
 * @return {string} The full path to the cache directory.
>>>>>>> Stashed changes
 */
function getCacheDir(optPath) {
  const dir = findCacheDir({name: 'gh-pages'});
  if (!optPath) {
    return dir;
  }

  return path.join(dir, filenamify(optPath));
}
exports.getCacheDir = getCacheDir;

function getRepo(options) {
  if (options.repo) {
    return Promise.resolve(options.repo);
  } else {
    const git = new Git(process.cwd(), options.git);
    return git.getRemoteUrl(options.remote);
  }
}

exports.defaults = {
  dest: '.',
  add: false,
  git: 'git',
  depth: 1,
  dotfiles: false,
  branch: 'gh-pages',
  remote: 'origin',
  src: '**/*',
  remove: '.',
  push: true,
  history: true,
  message: 'Updates',
<<<<<<< Updated upstream
  silent: false
=======
  silent: false,
>>>>>>> Stashed changes
};

/**
 * Push a git branch to a remote (pushes gh-pages by default).
 * @param {string} basePath The base path.
<<<<<<< Updated upstream
 * @param {Object} config Publish options.
 * @param {Function} callback Callback.
=======
 * @param {object} config Publish options.
 * @param {Function} callback Callback.
 * @return {Promise} A promise.
>>>>>>> Stashed changes
 */
exports.publish = function publish(basePath, config, callback) {
  if (typeof config === 'function') {
    callback = config;
    config = {};
  }

  const options = Object.assign({}, exports.defaults, config);

  // For backward compatibility before fixing #334
  if (options.only) {
    options.remove = options.only;
  }

  if (!callback) {
<<<<<<< Updated upstream
    callback = function(err) {
=======
    callback = function (err) {
>>>>>>> Stashed changes
      if (err) {
        log(err.message);
      }
    };
  }

  function done(err) {
    try {
      callback(err);
    } catch (err2) {
      log('Publish callback threw: %s', err2.message);
    }
  }

  try {
    if (!fs.statSync(basePath).isDirectory()) {
<<<<<<< Updated upstream
      done(new Error('The "base" option must be an existing directory'));
      return;
    }
  } catch (err) {
    done(err);
    return;
=======
      const err = new Error('The "base" option must be an existing directory');
      done(err);
      return Promise.reject(err);
    }
  } catch (err) {
    done(err);
    return Promise.reject(err);
>>>>>>> Stashed changes
  }

  const files = globby
    .sync(options.src, {
      cwd: basePath,
<<<<<<< Updated upstream
      dot: options.dotfiles
    })
    .filter(file => {
=======
      dot: options.dotfiles,
    })
    .filter((file) => {
>>>>>>> Stashed changes
      return !fs.statSync(path.join(basePath, file)).isDirectory();
    });

  if (!Array.isArray(files) || files.length === 0) {
    done(
      new Error('The pattern in the "src" property didn\'t match any files.')
    );
    return;
  }

  let repoUrl;
  let userPromise;
  if (options.user) {
    userPromise = Promise.resolve(options.user);
  } else {
    userPromise = getUser();
  }
<<<<<<< Updated upstream
  return userPromise.then(user =>
    getRepo(options)
      .then(repo => {
=======
  return userPromise.then((user) =>
    getRepo(options)
      .then((repo) => {
>>>>>>> Stashed changes
        repoUrl = repo;
        const clone = getCacheDir(repo);
        log('Cloning %s into %s', repo, clone);
        return Git.clone(repo, clone, options.branch, options);
      })
<<<<<<< Updated upstream
      .then(git => {
        return git.getRemoteUrl(options.remote).then(url => {
=======
      .then((git) => {
        return git.getRemoteUrl(options.remote).then((url) => {
>>>>>>> Stashed changes
          if (url !== repoUrl) {
            const message =
              'Remote url mismatch.  Got "' +
              url +
              '" ' +
              'but expected "' +
              repoUrl +
              '" in ' +
              git.cwd +
              '.  Try running the `gh-pages-clean` script first.';
            throw new Error(message);
          }
          return git;
        });
      })
<<<<<<< Updated upstream
      .then(git => {
=======
      .then((git) => {
>>>>>>> Stashed changes
        // only required if someone mucks with the checkout between builds
        log('Cleaning');
        return git.clean();
      })
<<<<<<< Updated upstream
      .then(git => {
        log('Fetching %s', options.remote);
        return git.fetch(options.remote);
      })
      .then(git => {
        log('Checking out %s/%s ', options.remote, options.branch);
        return git.checkout(options.remote, options.branch);
      })
      .then(git => {
=======
      .then((git) => {
        log('Fetching %s', options.remote);
        return git.fetch(options.remote);
      })
      .then((git) => {
        log('Checking out %s/%s ', options.remote, options.branch);
        return git.checkout(options.remote, options.branch);
      })
      .then((git) => {
>>>>>>> Stashed changes
        if (!options.history) {
          return git.deleteRef(options.branch);
        } else {
          return git;
        }
      })
<<<<<<< Updated upstream
      .then(git => {
=======
      .then((git) => {
>>>>>>> Stashed changes
        if (options.add) {
          return git;
        }

        log('Removing files');
        const files = globby
          .sync(options.remove, {
<<<<<<< Updated upstream
            cwd: path.join(git.cwd, options.dest)
          })
          .map(file => path.join(options.dest, file));
=======
            cwd: path.join(git.cwd, options.dest),
          })
          .map((file) => path.join(options.dest, file));
>>>>>>> Stashed changes
        if (files.length > 0) {
          return git.rm(files);
        } else {
          return git;
        }
      })
<<<<<<< Updated upstream
      .then(git => {
        log('Copying files');
        return copy(files, basePath, path.join(git.cwd, options.dest)).then(
          function() {
=======
      .then((git) => {
        if (options.nojekyll) {
          log('Creating .nojekyll');
          fs.createFileSync(path.join(git.cwd, '.nojekyll'));
        }
        if (options.cname) {
          log('Creating CNAME for %s', options.cname);
          fs.writeFileSync(path.join(git.cwd, 'CNAME'), options.cname);
        }
        log('Copying files');
        return copy(files, basePath, path.join(git.cwd, options.dest)).then(
          function () {
>>>>>>> Stashed changes
            return git;
          }
        );
      })
<<<<<<< Updated upstream
      .then(git => {
=======
      .then((git) => {
>>>>>>> Stashed changes
        return Promise.resolve(
          options.beforeAdd && options.beforeAdd(git)
        ).then(() => git);
      })
<<<<<<< Updated upstream
      .then(git => {
        log('Adding all');
        return git.add('.');
      })
      .then(git => {
=======
      .then((git) => {
        log('Adding all');
        return git.add('.');
      })
      .then((git) => {
>>>>>>> Stashed changes
        if (!user) {
          return git;
        }
        return git.exec('config', 'user.email', user.email).then(() => {
          if (!user.name) {
            return git;
          }
          return git.exec('config', 'user.name', user.name);
        });
      })
<<<<<<< Updated upstream
      .then(git => {
        log('Committing');
        return git.commit(options.message);
      })
      .then(git => {
        if (options.tag) {
          log('Tagging');
          return git.tag(options.tag).catch(error => {
=======
      .then((git) => {
        log('Committing');
        return git.commit(options.message);
      })
      .then((git) => {
        if (options.tag) {
          log('Tagging');
          return git.tag(options.tag).catch((error) => {
>>>>>>> Stashed changes
            // tagging failed probably because this tag alredy exists
            log(error);
            log('Tagging failed, continuing');
            return git;
          });
        } else {
          return git;
        }
      })
<<<<<<< Updated upstream
      .then(git => {
=======
      .then((git) => {
>>>>>>> Stashed changes
        if (options.push) {
          log('Pushing');
          return git.push(options.remote, options.branch, !options.history);
        } else {
          return git;
        }
      })
      .then(
        () => done(),
<<<<<<< Updated upstream
        error => {
=======
        (error) => {
>>>>>>> Stashed changes
          if (options.silent) {
            error = new Error(
              'Unspecified error (run without silent option for detail)'
            );
          }
          done(error);
        }
      )
  );
};

/**
 * Clean the cache directory.
 */
exports.clean = function clean() {
  fs.removeSync(getCacheDir());
};
